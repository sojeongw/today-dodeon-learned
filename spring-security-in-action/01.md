# 1. 오늘날의 보안

## 1.1. 스프링 시큐리티: 개념과 장점

- 애플리케이션 수준의 보안을 구현하기 위한 사실상의 표준
- 어노테이션, 빈 등 스프링의 방식을 이용해 보안을 구현할 수 있는 프레임워크

## 1.2. 소프트웨어 보안이란?

- 민감한 정보에 접근, 변경할 수 없게 막고 의도된 사용자 외의 대상은 데이터와 상호작용 할 수 없게 한다.
- 인증, 권한 부여, 데이터 저장소, 내부 메모리를 관리한다.

## 1.3. 보안이 중요한 이유는 무엇인가?

- 이미지가 손상되고 막대한 비용적 손해를 볼 수 있다.

## 1.4. 웹 애플리케이션의 일반적인 보안 취약성

### 1.4.1. 인증과 권한 부여의 취약성

- 인증
    - Authentication
    - 이용하려는 사람을 식별하는 프로세스
- 권한 부여
    - Authorization
    - 인증된 호출자가 특정 기능과 데이터에 대한 이용 권리가 있는지 확인하는 프로세스
- 다른 사람의 기능이나 데이터에 접근할 수 있다.
    - ex. 사용자의 제품을 검색할 때 누구의 것인지 확인하지 않는다.

### 1.4.2. 세션 고정

- 이미 생성된 세션 ID를 재이용해 유효한 사용자를 가장한다.
- 고유한 세션 ID를 할당하지 않아 재사용될 가능성이 있을 떄 발생한다.
- 악성 링크를 클릭하도록 유도하거나 스크립트를 주입해 실행하도록 할 수 있다.
- 예방책
    - 세션 ID를 고유하게 만들고 로그인에 성공하면 새로운 세션 ID를 발급해 기존 값을 무효화한다.
    - CORS를 구현해 필요한 출처에만 접근을 허용한다.

### 1.4.3. XSS(Cross-site scripting, 교차 사이트 스크립팅)

- 클라이언트 쪽 스크립트를 주입해 다른 사용자가 일을 실행하도록 하는 공격
- 계정 가장이나 디도스 같은 분산 공격에 참여할 수 있다.
- 스크립트로 사용자의 쿠키, 세션 토큰, 기타 정보를 훔쳐 사용자로 가장할 수 있다.
- 악의적 사이트로 사용자를 리디렉션 하거나 기밀 데이터를 추출할 수도 있다.
- 예방책
    - 입력값에 <script>처럼 공격에 사용되는 태그나 문자를 쓰지 못하도록 유효성 검사를 한다.
    - 사용자가 스크립트를 작성해도 일반 텍스트로 변환해 실행하지 않게 한다.

### 1.4.4. CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)

- 특정 작업을 호출하는 URL를 추출해 악의적으로 사용한다.
    - ex. 수정 api를 호출해 데이터를 조작한다.

### 1.4.5. 웹 애플리케이션의 주입 취약성

- 시스템에 특정 데이터를 유입해 데이터를 변경하고 검색한다.
- SQL, XPath, OS 명령, LDAP 주입 등
    - ex. SQL 쿼리를 변경하거나 실행해서 데이터를 변경, 삭제, 추출한다.

### 1.4.6. 민감한 데이터의 노출 처리

- 가장 기초적이고 단순하지만 여전히 흔한 실수 중 하나
- ex. 구성 파일에 자격 증명을 넣어둔다.
- 예방책
    - 로그에 기밀 정보를 포함하지 않는다.
        - 특히 예외 트레이스를 노출하지 않는다.
    - 응답 메시지에 세부 정보를 노출하지 않는다.
        - ex. 사용자 이름이 올바르지 않습니다. (X)
        - ex. 사용자 이름 또는 암호가 올바르지 않습니다. (O)
    - 중요한 기밀 데이터는 볼트에 넣는다.

### 1.4.7. 메서드 접근 제어 부족

- 애플리케이션의 한 계층에만 권한을 부여하는 것
    - ex. 컨트롤러에만 권한 부여가 수행된다면 동일한 서비스, 리포지토리를 다른 곳에서 이용할 때 문제가 발생할 수 있다.

### 1.4.8. 알려진 취약성이 있는 종속성 이용

- 이용하는 라이브러리나 프레임워크에 취약성이 있을 수 있다.
- 예방책
    - 그레이들 구성에 플러그인을 추가하면 정적 분석을 통해 알아낼 수 있다.

## 1.5. 다양한 아키텍처에 적용된 보안

### 1.5.1. 일체형 웹 애플리케이션 설계

- 백엔드와 프런트엔드 간의 분리가 없다.
- 서버 쪽 세션이 있으면 세션 고정 취약성과 CSRF 가능성을 고려해야 한다.
- 세션이 메모리에 유지되는 기간이 길면 힙 덤프 등 접근 가능성이 커진다.
- 스프링 시큐리티에서 기본으로 제공하는 CSRF 방지 토큰과 CORS 검증을 활용한다.

### 1.5.2. 백엔드/프런트엔드 분리를 위한 보안 설계

- 클라이언트가 웹, 앱 등 다양해서 CSRF, CORS 구성이 더 복잡하다.
- 서버 쪽 세션을 줄이고 클라이언트 쪽 세션으로 대체하는 것이 좋다.
- OAuth로 인증과 권한 부여를 구성한다.

### 1.5.3. OAuth 2 흐름 이해

1. 사용자가 클라이언트에 접근한다. 이때 백엔드의 리소스를 호출해야 한다.
2. 애플리케이션이 리소스를 호출하려면 액세스 토큰을 얻어야 한다.
3. 권한 부여 서버를 호출해서 자격 증명이나 갱신 토큰을 보낸다.
4. 자격 증명이나 갱신 토큰이 올바르면 권한 부여 서버가 새로운 액세스 토큰을 클라이언트에 반환한다.
5. 필요한 리소스를 호출할 때 헤더에 액세스 토큰을 이용한다.
    - 인증 토큰은 오래 유지 되지 않으며 만료되면 새 토큰을 받아야 한다. 필요한 경우 일찍 만료시킬 수도 있다.

- 장점
    - 클라이언트는 자격 증명을 저장할 필요가 없다.
    - 액세스 토큰과 갱신 토큰만 저장하면 된다.
    - 자격 증명을 노출하지 않는다.
    - 토큰으로 사용자를 가장할 경우 토큰 수명이 제한되므로 취약성도 제한된다.

### 1.5.4. API 키, 암호화 서명, IP 검증을 이용해 요청 보안

- 정적 API 키
    - 요청, 응답 헤더에 키를 이용한다.
    - 가장 약하고 트래픽이 외부로 이동하면 가로채기 쉽다.
    - 사용할 때는 IP 주소 허용 목록을 함께 결합한다.
- 암호화 서명
    - 연결을 통해 키를 보낼 필요가 없다는 장점이 있다.
- IP
    - 요청이 들어오는 특정 주소를 아는 경우 네트워크 계층에서 막는다.